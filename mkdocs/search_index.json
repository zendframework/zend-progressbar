{
    "docs": [
        {
            "location": "/", 
            "text": "../../README.md", 
            "title": "Home"
        }, 
        {
            "location": "/intro/", 
            "text": "Progress Bars\n\n\nzend-progressbar allows creating and updating progress bars in different\nenvironments. It consists of a single backend, which outputs the progress\nthrough one of the multiple adapters. On every update, it takes an absolute\nvalue and optionally a status message, and then calls the adapter with some\nprecalculated values like percentage and estimated time left.\n\n\nBasic Usage\n\n\nTo use the component, instantiate \nZend\\ProgressBar\\ProgressBar\n, providing both\na a min- and a max-value, and an adapter for providing data output. If you want\nto process a file, you would do something like:\n\n\nuse Zend\\ProgressBar\\ProgressBar;\n\n$progressBar = new ProgressBar($adapter, 0, $fileSize);\n\nwhile (! feof($fp)) {\n    // Do something\n    $progressBar-\nupdate($currentByteCount);\n}\n\n$progressBar-\nfinish();\n\n\n\n\nIn the first step, an instance of \nZend\\ProgressBar\\ProgressBar\n is created,\nwith a specific adapter, a min-value of 0 and a max-value of the total filesize.\nThen a file is processed and in every loop the progressbar is updated with the\ncurrent byte count. At the end of the loop, the progressbar status is set to\nfinished.\n\n\nYou can also call the \nupdate()\n method of \nProgressBar\n without arguments;\ndoing so recalculates ETA and notifies the adapter. This is useful when there is\nno data update but you want the progressbar to be updated.\n\n\nPersistent Progress\n\n\nIf you want the progressbar to be persistent over multiple requests, you can\ngive the name of a session namespace as fourth argument to the constructor. In\nthat case, the progressbar will not notify the adapter within the constructor,\nbut only when you call \nupdate()\n or \nfinish()\n. Additionally, the current\nvalue, the status text, and the start time for ETA calculation will be fetched\nin the next request run again.", 
            "title": "Intro"
        }, 
        {
            "location": "/intro/#progress-bars", 
            "text": "zend-progressbar allows creating and updating progress bars in different\nenvironments. It consists of a single backend, which outputs the progress\nthrough one of the multiple adapters. On every update, it takes an absolute\nvalue and optionally a status message, and then calls the adapter with some\nprecalculated values like percentage and estimated time left.", 
            "title": "Progress Bars"
        }, 
        {
            "location": "/intro/#basic-usage", 
            "text": "To use the component, instantiate  Zend\\ProgressBar\\ProgressBar , providing both\na a min- and a max-value, and an adapter for providing data output. If you want\nto process a file, you would do something like:  use Zend\\ProgressBar\\ProgressBar;\n\n$progressBar = new ProgressBar($adapter, 0, $fileSize);\n\nwhile (! feof($fp)) {\n    // Do something\n    $progressBar- update($currentByteCount);\n}\n\n$progressBar- finish();  In the first step, an instance of  Zend\\ProgressBar\\ProgressBar  is created,\nwith a specific adapter, a min-value of 0 and a max-value of the total filesize.\nThen a file is processed and in every loop the progressbar is updated with the\ncurrent byte count. At the end of the loop, the progressbar status is set to\nfinished.  You can also call the  update()  method of  ProgressBar  without arguments;\ndoing so recalculates ETA and notifies the adapter. This is useful when there is\nno data update but you want the progressbar to be updated.", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/intro/#persistent-progress", 
            "text": "If you want the progressbar to be persistent over multiple requests, you can\ngive the name of a session namespace as fourth argument to the constructor. In\nthat case, the progressbar will not notify the adapter within the constructor,\nbut only when you call  update()  or  finish() . Additionally, the current\nvalue, the status text, and the start time for ETA calculation will be fetched\nin the next request run again.", 
            "title": "Persistent Progress"
        }, 
        {
            "location": "/adapters/", 
            "text": "Standard Adapters\n\n\nzend-progressbar comes with the following three adapters:\n\n\n\n\nZend\\Progressbar\\Adapter\\Console\n\n\nZend\\Progressbar\\Adapter\\JsPush\n\n\nZend\\ProgressBar\\Adapter\\JsPull\n\n\n\n\nConsole Adapter\n\n\nZend\\ProgressBar\\Adapter\\Console\n is a text-based adapter for terminals. It can\nautomatically detect terminal widths, but supports custom widths as well. You\ncan define which elements are displayed with the progressbar as well customize\nthe order of them. You can also define the style of the progressbar itself.\n\n\n\n\nAutomatic console width recognition\n\n\nshell_exec()\n is required for this feature to work on *nix based systems. On\nWindows, there is always a fixed terminal width of 80 characters, so no\nrecognition is required there.\n\n\n\n\nYou can set the adapter options either via the \nset*()\n methods, or provide an\narray or \nTraversable\n instance with options as first parameter to the\nconstructor. The available options are:\n\n\n\n\n\n\n\n\nOption name\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noutputStream\n\n\nstring|resource\n\n\nA different output stream, if you don't want to stream to \nSTDOUT\n. Can be any other stream like \nphp://stderr\n or a path to a file.\n\n\n\n\n\n\nwidth\n\n\nint|ProgressBar::AUTO\n\n\nConsole width to use; \nProgressBar::AUTO\n indicates the adapter should autodetect the width.\n\n\n\n\n\n\nelements\n\n\nnull|array\n\n\nWhich elements to include in the display; \nnull\n to include all, or an array with one of the \nConsole\n constants, as detailed below.\n\n\n\n\n\n\ntextWidth\n\n\nint\n\n\nWidth in characters of the \nELEMENT_TEXT\n element. Default is 20.\n\n\n\n\n\n\ncharset\n\n\nstring\n\n\nCharset of the \nELEMENT_TEXT\n element. Default is utf-8.\n\n\n\n\n\n\nbarLeftChar\n\n\nstring\n\n\nString to use on the left-hand side of the progressbar indicator.\n\n\n\n\n\n\nbarRightChar\n\n\nstring\n\n\nString to use on the right-hand side of the progressbar indicator.\n\n\n\n\n\n\nbarIndicatorChar\n\n\nstring\n\n\nString to use within the progressbar indicator to indicate progress; can be empty.\n\n\n\n\n\n\n\n\nTo determine which elements to display in the progressbar, use one or more of\nthe following constants:\n\n\n\n\n\n\n\n\nOption name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nELEMENT_PERCENT\n\n\nThe current value in percent.\n\n\n\n\n\n\nELEMENT_BAR\n\n\nThe visual bar which display the percentage.\n\n\n\n\n\n\nELEMENT_ETA\n\n\nThe automatic calculated ETA. This element is firstly displayed after five seconds, because in this time, it is not able to calculate accurate results.\n\n\n\n\n\n\nELEMENT_TEXT\n\n\nAn optional status message about the current process.\n\n\n\n\n\n\n\n\nJsPush Adapter\n\n\nZend\\ProgressBar\\Adapter\\JsPush\n is an adapter allowing you to update a\nbrowser-based progressbar via Javascript Push. This means that no second\nconnection is required to gather the status about a running process, but that\nthe process itself sends its status directly to the browser.\n\n\nYou can set the adapter options either via the \nset()\n methods or provide an\narray or \nTraversable\n instance with options as the first parameter to the\nconstructor. The available options are:\n\n\n\n\n\n\n\n\nOption name\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nupdateMethodName\n\n\nstring\n\n\nThe JavaScript method which should be called on every update. Default value is \nZend\\ProgressBar\\Update\n.\n\n\n\n\n\n\nfinishMethodName\n\n\nnull|string\n\n\nThe JavaScript method which should be called when sending the finish status. Default value is \nNULL\n, which means nothing is done.\n\n\n\n\n\n\n\n\nTo use this adapter, first create a progressbar in your browser, either with\nJavaScript or plain HTML. Then define the update method and optionally a finish\nmethod in JavaScript; both should expect a JSON object as the only argument.\nThen call a webpage with the long-running process in a hidden \niframe\n or\n\nobject\n tag. While the process is running, the adapter will call the update\nmethod on every update with a JSON object, containing the following parameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncurrent\n\n\nThe current absolute value detailing upload status.\n\n\n\n\n\n\nmax\n\n\nThe max absolute value, indicating total upload size.\n\n\n\n\n\n\npercent\n\n\nThe calculated percentage complete of the upload.\n\n\n\n\n\n\ntimeTaken\n\n\nThe elapsed time of the upload currently.\n\n\n\n\n\n\ntimeRemaining\n\n\nThe expected time until the upload finishes.\n\n\n\n\n\n\ntext\n\n\nThe optional status message, if given.\n\n\n\n\n\n\n\n\nBasic example for the client-side\n\n\nThis example illustrates a basic setup of HTML, CSS, and JavaScript for the \nJsPush\n adapter\n\n\ndiv id=\nzend-progressbar-container\n\n    \ndiv id=\nzend-progressbar-done\n/div\n\n\n/div\n\n\n\niframe src=\nlong-running-process.php\n id=\nlong-running-process\n/iframe\n\n\n\n\n#long-running-process {\n    position: absolute;\n    left: -100px;\n    top: -100px;\n\n    width: 1px;\n    height: 1px;\n}\n\n#zend-progressbar-container {\n    width: 100px;\n    height: 30px;\n\n    border: 1px solid #000000;\n    background-color: #ffffff;\n}\n\n#zend-progressbar-done {\n    width: 0;\n    height: 30px;\n\n    background-color: #000000;\n}\n\n\n\n\nfunction Zend\\ProgressBar\\Update(data)\n{\n    document.getElementById('zend-progressbar-done').style.width = data.percent + '%';\n}\n\n\n\n\nThis will create a container with a black border and a block which indicates the\ncurrent process. You should not hide the \niframe\n or \nobject\n using \ndisplay: none;\n,\nas some browsers (such as Safari 2) will not load the actual content then.\n\n\nInstead of creating your custom progressbar, you may want to use one of the\navailable JavaScript libraries like Dojo, jQuery etc.:\n\n\n\n\nDojo\n\n\njQuery\n\n\nMooTools\n\n\nPrototype\n\n\n\n\n\n\nInterval of updates\n\n\nDo not send too many updates, as every update has a minimum size of 1kb. This\nis a requirement for the Safari browser to actually render and execute the\nfunction call. Internet Explorer has a similar limitation of 256 bytes.\n\n\n\n\nJsPull Adapter\n\n\nZend\\ProgressBar\\Adapter\\JsPull\n is the opposite of \nJsPush\n, as it requires\nthe browser to pull for new updates, instead of\npushing updates directly without intervention.\n\n\nIn general, you should use this adapter with the\n\npersistence option of the \nZend\\ProgressBar\\ProgressBar\n.\nOn notify, the adapter sends a JSON string to the browser, which looks exactly\nlike the JSON string which is sent by the \nJsPush\n adapter, with one difference:\nit contains an additional parameter, \nfinished\n, which is either \nfalse\n when\n\nupdate()\n is called or \ntrue\n, when \nfinish()\n is called.\n\n\nYou can set the adapter options either via the \nset*()\n methods, or give an\narray or \nTraversable\n instance with options as first parameter to\nthe constructor. The available options are:\n\n\n\n\n\n\n\n\nOption name\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexitAfterSend\n\n\nbool\n\n\nWhether or not to exit the current request after the data is sent to the browser; default is \ntrue\n.", 
            "title": "Adapters"
        }, 
        {
            "location": "/adapters/#standard-adapters", 
            "text": "zend-progressbar comes with the following three adapters:   Zend\\Progressbar\\Adapter\\Console  Zend\\Progressbar\\Adapter\\JsPush  Zend\\ProgressBar\\Adapter\\JsPull", 
            "title": "Standard Adapters"
        }, 
        {
            "location": "/adapters/#console-adapter", 
            "text": "Zend\\ProgressBar\\Adapter\\Console  is a text-based adapter for terminals. It can\nautomatically detect terminal widths, but supports custom widths as well. You\ncan define which elements are displayed with the progressbar as well customize\nthe order of them. You can also define the style of the progressbar itself.", 
            "title": "Console Adapter"
        }, 
        {
            "location": "/adapters/#automatic-console-width-recognition", 
            "text": "shell_exec()  is required for this feature to work on *nix based systems. On\nWindows, there is always a fixed terminal width of 80 characters, so no\nrecognition is required there.   You can set the adapter options either via the  set*()  methods, or provide an\narray or  Traversable  instance with options as first parameter to the\nconstructor. The available options are:     Option name  Type  Description      outputStream  string|resource  A different output stream, if you don't want to stream to  STDOUT . Can be any other stream like  php://stderr  or a path to a file.    width  int|ProgressBar::AUTO  Console width to use;  ProgressBar::AUTO  indicates the adapter should autodetect the width.    elements  null|array  Which elements to include in the display;  null  to include all, or an array with one of the  Console  constants, as detailed below.    textWidth  int  Width in characters of the  ELEMENT_TEXT  element. Default is 20.    charset  string  Charset of the  ELEMENT_TEXT  element. Default is utf-8.    barLeftChar  string  String to use on the left-hand side of the progressbar indicator.    barRightChar  string  String to use on the right-hand side of the progressbar indicator.    barIndicatorChar  string  String to use within the progressbar indicator to indicate progress; can be empty.     To determine which elements to display in the progressbar, use one or more of\nthe following constants:     Option name  Description      ELEMENT_PERCENT  The current value in percent.    ELEMENT_BAR  The visual bar which display the percentage.    ELEMENT_ETA  The automatic calculated ETA. This element is firstly displayed after five seconds, because in this time, it is not able to calculate accurate results.    ELEMENT_TEXT  An optional status message about the current process.", 
            "title": "Automatic console width recognition"
        }, 
        {
            "location": "/adapters/#jspush-adapter", 
            "text": "Zend\\ProgressBar\\Adapter\\JsPush  is an adapter allowing you to update a\nbrowser-based progressbar via Javascript Push. This means that no second\nconnection is required to gather the status about a running process, but that\nthe process itself sends its status directly to the browser.  You can set the adapter options either via the  set()  methods or provide an\narray or  Traversable  instance with options as the first parameter to the\nconstructor. The available options are:     Option name  Type  Description      updateMethodName  string  The JavaScript method which should be called on every update. Default value is  Zend\\ProgressBar\\Update .    finishMethodName  null|string  The JavaScript method which should be called when sending the finish status. Default value is  NULL , which means nothing is done.     To use this adapter, first create a progressbar in your browser, either with\nJavaScript or plain HTML. Then define the update method and optionally a finish\nmethod in JavaScript; both should expect a JSON object as the only argument.\nThen call a webpage with the long-running process in a hidden  iframe  or object  tag. While the process is running, the adapter will call the update\nmethod on every update with a JSON object, containing the following parameters:     Parameter  Description      current  The current absolute value detailing upload status.    max  The max absolute value, indicating total upload size.    percent  The calculated percentage complete of the upload.    timeTaken  The elapsed time of the upload currently.    timeRemaining  The expected time until the upload finishes.    text  The optional status message, if given.", 
            "title": "JsPush Adapter"
        }, 
        {
            "location": "/adapters/#basic-example-for-the-client-side", 
            "text": "This example illustrates a basic setup of HTML, CSS, and JavaScript for the  JsPush  adapter  div id= zend-progressbar-container \n     div id= zend-progressbar-done /div  /div  iframe src= long-running-process.php  id= long-running-process /iframe  #long-running-process {\n    position: absolute;\n    left: -100px;\n    top: -100px;\n\n    width: 1px;\n    height: 1px;\n}\n\n#zend-progressbar-container {\n    width: 100px;\n    height: 30px;\n\n    border: 1px solid #000000;\n    background-color: #ffffff;\n}\n\n#zend-progressbar-done {\n    width: 0;\n    height: 30px;\n\n    background-color: #000000;\n}  function Zend\\ProgressBar\\Update(data)\n{\n    document.getElementById('zend-progressbar-done').style.width = data.percent + '%';\n}  This will create a container with a black border and a block which indicates the\ncurrent process. You should not hide the  iframe  or  object  using  display: none; ,\nas some browsers (such as Safari 2) will not load the actual content then.  Instead of creating your custom progressbar, you may want to use one of the\navailable JavaScript libraries like Dojo, jQuery etc.:   Dojo  jQuery  MooTools  Prototype", 
            "title": "Basic example for the client-side"
        }, 
        {
            "location": "/adapters/#interval-of-updates", 
            "text": "Do not send too many updates, as every update has a minimum size of 1kb. This\nis a requirement for the Safari browser to actually render and execute the\nfunction call. Internet Explorer has a similar limitation of 256 bytes.", 
            "title": "Interval of updates"
        }, 
        {
            "location": "/adapters/#jspull-adapter", 
            "text": "Zend\\ProgressBar\\Adapter\\JsPull  is the opposite of  JsPush , as it requires\nthe browser to pull for new updates, instead of\npushing updates directly without intervention.  In general, you should use this adapter with the persistence option of the  Zend\\ProgressBar\\ProgressBar .\nOn notify, the adapter sends a JSON string to the browser, which looks exactly\nlike the JSON string which is sent by the  JsPush  adapter, with one difference:\nit contains an additional parameter,  finished , which is either  false  when update()  is called or  true , when  finish()  is called.  You can set the adapter options either via the  set*()  methods, or give an\narray or  Traversable  instance with options as first parameter to\nthe constructor. The available options are:     Option name  Type  Description      exitAfterSend  bool  Whether or not to exit the current request after the data is sent to the browser; default is  true .", 
            "title": "JsPull Adapter"
        }, 
        {
            "location": "/upload/", 
            "text": "File Upload Handlers\n\n\nzend-progressbar provides handlers that can give you the actual state of a file\nupload in progress. To use this feature you need to choose one of the upload\nprogress handlers (APC, uploadprogress, or session) and ensure that your server\nsetup has the appropriate extension or feature enabled. All of the progress\nhandlers use the same interface.\n\n\nWhen uploading a file via HTTP POST, you must also include the progress identifier in a hidden\ninput. The \nFile Upload Progress View Helpers\n\nprovide a convenient way to add the hidden input based on your handler type.\n\n\nMethods of Reporting Progress\n\n\nThere are two methods for reporting the current upload progress status: using a\nProgressBar Adapter, or using the returned status array manually.\n\n\nUsing a ProgressBar Adapter\n\n\nA zend-progressbar adapter can be used to display upload progress to your users.\n\n\nuse Zend\\I18n\\Filter\\Alnum as AlnumFilter;\nuse Zend\\ProgressBar\\Adapter;\nuse Zend\\ProgressBar\\Upload;\n\n$adapter  = new Adapter\\JsPush();\n$progress = new Upload\\SessionProgress();\n\n$filter   = new AlnumFilter(false, 'en_US');\n$id       = $filter-\nfilter($_GET['id']);\n\n$status   = null;\nwhile (empty($status['done'])) {\n    $status = $progress-\ngetProgress($id);\n}\n\n\n\n\nEach time the \ngetProgress()\n method is called, the adapter will be updated.\n\n\nUsing the Status Array\n\n\nYou can also work manually with \ngetProgress()\n without using an adapter.\n\n\ngetProgress()\n will return an array with several keys. They will sometimes\ndiffer based on the specific upload handler used, but the following keys are\nalways standard:\n\n\n\n\n\n\n\n\nKey name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntotal\n\n\nThe total file size of the uploaded file(s) in bytes as integer.\n\n\n\n\n\n\ncurrent\n\n\nThe current uploaded file size in bytes as integer.\n\n\n\n\n\n\nrate\n\n\nThe average upload speed in bytes per second as integer.\n\n\n\n\n\n\ndone\n\n\nReturns \nTRUE\n when the upload is finished and \nFALSE\n otherwise.\n\n\n\n\n\n\nmessage\n\n\nA status message. Either the progress as text in the form \n10kB / 200kB\n, or a helpful error message in the case of a problem (such as: no upload in progress, failure while retrieving the data for the progress, or that the upload has been canceled).\n\n\n\n\n\n\n\n\nAll other returned keys are provided directly from the specific handler.\n\n\nAn example of using the status array manually:\n\n\nuse Zend\\ProgressBar\\Upload\\SessionProgress;\nuse Zend\\View\\Model\\JsonModel;\n\n// In a Controller...\n\npublic function sessionProgressAction()\n{\n    $id = $this-\nparams()-\nfromQuery('id', null);\n    $progress = new SessionProgress();\n    return new JsonModel($progress-\ngetProgress($id));\n}\n\n// Returns JSON\n//{\n//    \ntotal\n    : 204800,\n//    \ncurrent\n  : 10240,\n//    \nrate\n     : 1024,\n//    \nmessage\n  : \n10kB / 200kB\n,\n//    \ndone\n     : false\n//}\n\n\n\n\nStandard Handlers\n\n\nzend-progressbar comes with the following three upload handlers:\n\n\n\n\nApcProgress\n\n\nSessionProgress\n\n\nUploadProgress\n\n\n\n\nAPC Progress Handler\n\n\nZend\\ProgressBar\\Upload\\ApcProgress\n uses the \nAPC extension\n\nfor tracking upload progress.\n\n\n\n\nExtension required\n\n\nThe \nAPC extension\n is required when using this handler.\n\n\n\n\nThis handler is best used with the\n\nFormFileApcProgress\n\nview helper, to provide a hidden element with the upload progress identifier.\n\n\nSession Progress Handler\n\n\nThe \nZend\\ProgressBar\\Upload\\SessionProgress\n handler uses the PHP\n\nSession Progress\n feature for tracking\nupload progress.\n\n\nThis handler is best used with the\n\nFormFileSessionProgress\n\nview helper, to provide a hidden element with the upload progress identifier.\n\n\nUpload Progress Handler\n\n\nThe \nZend\\ProgressBar\\Upload\\UploadProgress\n handler uses the\n\nPECL Uploadprogress extension\n for\ntracking upload progress.\n\n\n\n\nExtension required\n\n\nThe \nPECL Uploadprogress extension\n\nis required in order to use this handler.\n\n\n\n\nThis handler is best used with the\n\nFormFileUploadProgress\n\nview helper, to provide a hidden element with the upload progress identifier.", 
            "title": "File Upload Handlers"
        }, 
        {
            "location": "/upload/#file-upload-handlers", 
            "text": "zend-progressbar provides handlers that can give you the actual state of a file\nupload in progress. To use this feature you need to choose one of the upload\nprogress handlers (APC, uploadprogress, or session) and ensure that your server\nsetup has the appropriate extension or feature enabled. All of the progress\nhandlers use the same interface.  When uploading a file via HTTP POST, you must also include the progress identifier in a hidden\ninput. The  File Upload Progress View Helpers \nprovide a convenient way to add the hidden input based on your handler type.", 
            "title": "File Upload Handlers"
        }, 
        {
            "location": "/upload/#methods-of-reporting-progress", 
            "text": "There are two methods for reporting the current upload progress status: using a\nProgressBar Adapter, or using the returned status array manually.", 
            "title": "Methods of Reporting Progress"
        }, 
        {
            "location": "/upload/#using-a-progressbar-adapter", 
            "text": "A zend-progressbar adapter can be used to display upload progress to your users.  use Zend\\I18n\\Filter\\Alnum as AlnumFilter;\nuse Zend\\ProgressBar\\Adapter;\nuse Zend\\ProgressBar\\Upload;\n\n$adapter  = new Adapter\\JsPush();\n$progress = new Upload\\SessionProgress();\n\n$filter   = new AlnumFilter(false, 'en_US');\n$id       = $filter- filter($_GET['id']);\n\n$status   = null;\nwhile (empty($status['done'])) {\n    $status = $progress- getProgress($id);\n}  Each time the  getProgress()  method is called, the adapter will be updated.", 
            "title": "Using a ProgressBar Adapter"
        }, 
        {
            "location": "/upload/#using-the-status-array", 
            "text": "You can also work manually with  getProgress()  without using an adapter.  getProgress()  will return an array with several keys. They will sometimes\ndiffer based on the specific upload handler used, but the following keys are\nalways standard:     Key name  Description      total  The total file size of the uploaded file(s) in bytes as integer.    current  The current uploaded file size in bytes as integer.    rate  The average upload speed in bytes per second as integer.    done  Returns  TRUE  when the upload is finished and  FALSE  otherwise.    message  A status message. Either the progress as text in the form  10kB / 200kB , or a helpful error message in the case of a problem (such as: no upload in progress, failure while retrieving the data for the progress, or that the upload has been canceled).     All other returned keys are provided directly from the specific handler.  An example of using the status array manually:  use Zend\\ProgressBar\\Upload\\SessionProgress;\nuse Zend\\View\\Model\\JsonModel;\n\n// In a Controller...\n\npublic function sessionProgressAction()\n{\n    $id = $this- params()- fromQuery('id', null);\n    $progress = new SessionProgress();\n    return new JsonModel($progress- getProgress($id));\n}\n\n// Returns JSON\n//{\n//     total     : 204800,\n//     current   : 10240,\n//     rate      : 1024,\n//     message   :  10kB / 200kB ,\n//     done      : false\n//}", 
            "title": "Using the Status Array"
        }, 
        {
            "location": "/upload/#standard-handlers", 
            "text": "zend-progressbar comes with the following three upload handlers:   ApcProgress  SessionProgress  UploadProgress", 
            "title": "Standard Handlers"
        }, 
        {
            "location": "/upload/#apc-progress-handler", 
            "text": "Zend\\ProgressBar\\Upload\\ApcProgress  uses the  APC extension \nfor tracking upload progress.", 
            "title": "APC Progress Handler"
        }, 
        {
            "location": "/upload/#extension-required", 
            "text": "The  APC extension  is required when using this handler.   This handler is best used with the FormFileApcProgress \nview helper, to provide a hidden element with the upload progress identifier.", 
            "title": "Extension required"
        }, 
        {
            "location": "/upload/#session-progress-handler", 
            "text": "The  Zend\\ProgressBar\\Upload\\SessionProgress  handler uses the PHP Session Progress  feature for tracking\nupload progress.  This handler is best used with the FormFileSessionProgress \nview helper, to provide a hidden element with the upload progress identifier.", 
            "title": "Session Progress Handler"
        }, 
        {
            "location": "/upload/#upload-progress-handler", 
            "text": "The  Zend\\ProgressBar\\Upload\\UploadProgress  handler uses the PECL Uploadprogress extension  for\ntracking upload progress.", 
            "title": "Upload Progress Handler"
        }, 
        {
            "location": "/upload/#extension-required_1", 
            "text": "The  PECL Uploadprogress extension \nis required in order to use this handler.   This handler is best used with the FormFileUploadProgress \nview helper, to provide a hidden element with the upload progress identifier.", 
            "title": "Extension required"
        }
    ]
}